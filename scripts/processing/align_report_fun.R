library(ggplot2)
library(plotly)

#' Drop-seq barcode summary statistics
#'
#' Calculate number and percentage of failed cell and molecule (umi) barcodes from
#' TagBamWithReadSequenceExtended summary output.
#'
#' @param cell_bcs_file,mol_bcs_file Paths to barcode cell and molecule summary files generated by
#' TagBamWithReadSequenceExtended.
#'
#' @return A data.frame containing summary statistics.
bc_summary <- function(cell_bcs_file, mol_bcs_file) {

  # define function to count failed barcodes
  failed_bcs <- function(bcs, bc_type) {

    # calculate summary stats
    n_bcs <- sum(bcs[, 2])
    n_failed <- sum(bcs[-1, 2])
    perc_failed <- round((100 * sum(bcs[-1, 2]) / sum(bcs[, 2])), digits = 3)

    # create data.frame containing stats
    data.frame(barcode_type = bc_type,
               barcodes = n_bcs,
               barcodes_with_failed_bases = n_failed,
               percentage = perc_failed
               )
  }

  # read data
  cell_bcs <- read.table(cell_bcs_file, header = TRUE)
  mol_bcs <- read.table(mol_bcs_file, header = TRUE)

  # process cell barcodes
  num_cell_bcs <- failed_bcs(cell_bcs, bc_type = "CELL")
  num_mol_bcs <- failed_bcs(mol_bcs, bc_type = "UMI")

  # merge into one data.frame
  rbind(num_cell_bcs, num_mol_bcs)

}

#' Adapter trimming histogram
#'
#' Plot the number of bases clipped from Drop-seq genome reads by TrimStartingSequence from Drop-seq
#' tools.
#'
#' @param adapter_trim_file Path to the TrimStartingSequence summary file.
#'
#' @param sample Sample name for main title.
#'
#' @param total_reads (optional) Number of total reads. If provided, the percentage of reads that
#' were trimmed will be included in the plot title.
adapter_trim_hist <- function(adapter_trim_file, sample, total_reads = NULL) {

  # read data
  adapter_trim <- read.table(adapter_trim_file, header = TRUE, skip = 5)

  # generate title
  if (!is.null(total_reads)) {

    # calculate precentage of trimmed reads
    perc_trim <- round(sum(adapter_trim$VALUE) / total_reads * 100, digits = 3)

    # make title
    title <- paste0(sample, " adapter trimmed reads (", perc_trim, "%)")

  }else{

    title <- paste(sample, "adapter trimmed reads")

  }

  # plot histogram
  ggplot(adapter_trim, aes(BIN, VALUE)) +
    geom_bar(stat = "identity") +
    labs(x = "Number of clipped bases", y = "Reads", title = title) +
    theme_bw()

}

#' PolyA trimming histogram
#'
#' Plot post trimming read lengths of Drop-seq reads that were trimmed by PolyATrimmer from Drop-seq
#' tools.
#'
#' @param polyA_trim_file Path to the PolyATrimmer summary file.
#'
#' @param sample Sample name for main title.
#'
#' @param total_reads (optional) Number of total reads. If provided, the percentage of reads that
#' were trimmed will be included in the plot title.
polyA_trim_hist <- function(polyA_trim_file, sample, total_reads = NULL) {

  # read data
  polyA_trim <- read.table(polyA_trim_file, header = TRUE, skip = 5)

  # generate title
  if (!is.null(total_reads)) {

    # calculate precentage of trimmed reads
    perc_trim <- round(sum(polyA_trim$VALUE) / total_reads * 100, digits = 3)

    # make title
    title <- paste0(sample, " polyA trimmed reads (", perc_trim, "%)")

  }else{

    # make title
    title <- paste(sample, "polyA trimmed reads")

  }

  # plot histogram
  ggplot(polyA_trim, aes(BIN, VALUE)) +
    geom_bar(stat = "identity") +
    labs(x = "Read lengths after trimming (bp)", y = "Reads", title = title) +
    theme_bw()

}

#' Extract STAR mapping categories
#'
#' Extract percentage of reads falling into different mapping categories from the STAR log file
#' \code{Log.final.out}.
#'
#' @param star_log_file Path to the \code{Log.final.out} STAR log file.
get_mapping_cats <- function(star_log_file) {

  # read log file
  star_log <- readLines(star_log_file)

  # extract total number of reads
  total_reads <- star_log[6]

  # extract lines containing desired data
  perc_reads <- c("uniquely_mapped" = star_log[10],
                   "multi_mapped" = star_log[25],
                   "too_many_loci" = star_log[27],
                   "umapped_mismatch" = star_log[29],
                   "unmapped_short" = star_log[30],
                   "unmapped_other" = star_log[31]
                   )

  # only retain numbers from strings
  total_reads <- gsub(total_reads, pattern = "[^0-9]", replacement = "")
  perc_reads <- gsub(perc_reads, pattern = "[^0-9.]", replacement = "")

  # get mapping categories and convert to factor with specified levels
  categories <- factor(names(perc_reads), levels = names(perc_reads))

  # create data.frame with percentage of reads in mapping cats
  data.frame(category = categories, perc_reads = as.numeric(perc_reads))

}

#' Plot STAR mapping categories
#'
#' Plot percentage of reads falling into different mapping categories as bar chart.
#'
#' @param mapping_cats data.frame containing the percentage of reads in mapping categories produced
#' by get_mapping_cats().
#'
#' @param sample Sample name for main title.
#'
#' @param total_reads (optional) Number of total reads. If provided the total number of reads is
#' added to the plot title.
plot_mapping_cats <- function(mapping_cats, sample, total_reads = NULL) {

  # generate title
  if (!is.null(total_reads)) {

    title <- paste0(sample, " mapping results (total reads: ", total_reads, ")")

  }else{

    title <- paste0(sample, " mapping results")

  }

  # create barplot showing percentage of reads in mapping categories
  ggplot(mapping_cats, aes(x = category, y = perc_reads)) +
    geom_bar(stat = "identity") +
    labs(y = "percentage of reads", x = "STAR mapping category", title = title) +
    scale_y_continuous(breaks = seq(0, 100, by = 20), limits = c(0, 100)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

}

#' Read bead synthesis error summary
#'
#' Read summary data on bead synthesis errors produced by DetectBeadSynthesisErrors from Drop-seq
#' tools.
#'
#' @param synthesis_error_file Path to DetectBeadSynthesisErrors summary file.
#'
#' @return A list with two data.frames containing bead synthesis metrics and histogram data.
read_synthesis_error <- function(synthesis_error_file) {

  # read summary data
  bc_error_dat <- readLines(synthesis_error_file)

  # remove first and last empty line
  bc_error_dat <- bc_error_dat[-c(1,length(bc_error_dat))]

  # remove comment lines
  bc_error_dat <- grep(bc_error_dat, pattern = "^#+\\s.+", perl = TRUE,
                       value = TRUE, invert = TRUE)

  # find empty line separating metrics from histogram tables
  sep_line <- which(bc_error_dat == "")

  # split strings into vectors
  bc_error_dat <- strsplit(bc_error_dat, split = "\t")

  # transform into numbers
  bc_error_dat <- lapply(bc_error_dat, FUN = type.convert, as.is = TRUE)

  # extract metrics table and convert to data.frame
  metrics <- bc_error_dat[1:(sep_line - 1)]
  metrics_df <- as.data.frame(do.call(rbind, metrics[-1]))
  colnames(metrics_df) <- metrics[[1]]

  # extract histogram table and convert to data.frame
  hist <- bc_error_dat[(sep_line + 1):length(bc_error_dat)]
  hist_df <- as.data.frame(do.call(rbind, hist[-1]))
  colnames(hist_df) <- hist[[1]]

  # return list containing both data.frames
  list(metrics = metrics_df, hist = hist_df)

}

#' Synthesis error histogram
#'
#' Cell barcode synthesis errors lead to fixed Ts at the end of UMI sequences. This plot shows the
#' number of cells with detected fixed Ts and the base positions where the errors are detected.
#'
#' @param synthesis_error_dat List containing synthesis error data produced by
#' read_synthesis_error().
#'
#' @param sample Sample name for main title.
#'
#' @param cell_bc_length,mol_bc_length Length (bp) of cell and molecule (UMI) barcodes.
synthesis_error_hist <- function(synthesis_error_dat, sample,
                                 cell_bc_length = 12, mol_bc_length = 8) {

  # extract histogram data
  hist <- synthesis_error_dat$hist

  # create data.frame with barcode structure and position where synthesis errors are detected
  # (fixed Ts in UMI)
  barcode <- data.frame(base = 1:(cell_bc_length + mol_bc_length),
                        Barcode = factor(c(rep("cell", cell_bc_length), rep("UMI", mol_bc_length)),
                                         levels = c("cell", "UMI")),
                        fixed_T = 0L)

  barcode[hist[, 1] + cell_bc_length, "fixed_T"] <- hist[, 2]

  # define colors for plot
  bc_cols <- c("dodgerblue2", "firebrick1")
  axis_cols <- c(rep(bc_cols[1], cell_bc_length),
                 rep(bc_cols[2], mol_bc_length))

  # plot histogram
  ggplot(barcode, aes(x = base, y = fixed_T, fill = Barcode)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = bc_cols) +
    labs(title = paste0(sample, ": Detected fixed Ts in UMIs"),
         x = "Base position in barcode",
         y = "Number of cells with fixed Ts") +
    scale_x_continuous(breaks = c(1:(cell_bc_length + mol_bc_length))) +
    theme_bw() +
    theme(axis.text.x = element_text(color = axis_cols))

}

#' Cumulative fraction of reads per cell barcode
#'
#' Calculate cumulative fraction of reads per detected cell barcode. The cumulative fraction can be
#' plotted to estimate the number of sequenced cells by identifying the "knee" of the distribution.
#' For further details on selection of cells, see the Drop-seq alignment cookbook provided by the
#' \href{http://mccarrolllab.com/dropseq/}{McCarroll lab}.
#'
#' @param read_counts_file Path to output file from BAMTagHistogram containing the number of reads
#' per cell barcode. This file should contain two columns, where the number of reads must be in the
#' first and the barcode identity in the second column.
#'
#' @return A data.frame containing the original data in read_counts with an added columns containing
#' the cumulative sum and fraction.
cumfrac_rpc <- function(read_counts_file) {
  
  # load read per cell file
  read_counts <- read.table(read_counts_file, stringsAsFactors = FALSE)
  colnames(read_counts)[1:2] <- c("reads", "cell_barcode")
  
  # make sure that read_counts is ordered correctly
  read_counts <- read_counts[order(read_counts[, 1], decreasing = TRUE), ]
  
  # calculate cumulative sum
  reads_cumsum <- cumsum(read_counts[, 1])
  
  # calculate cumulative fraction
  reads_cumfrac <- reads_cumsum / max(reads_cumsum)
  
  # create output data.frame
  cbind(read_counts, reads_cumsum, reads_cumfrac)
  
}

#' Plot cumulative fraction of reads per cell barcode
#'
#' Plot cumulative fraction of reads per detected cell barcode. The cumulative fraction can be
#' plotted to estimate the number of sequenced cells by identifying the "knee" of the distribution.
#' For further details on selection of cells, see the Drop-seq alignment cookbook provided by the
#' \href{http://mccarrolllab.com/dropseq/}{McCarroll lab}.
#'
#' @param cumfrac A data.frame containing the cumulative fraction of reads per cell barcode
#' calculated by cumfrac_rpc().
#'
#' @param nbcs Number of cell barcodes to be shown on the x-axis.
#'
#' @param all Logical. If TRUE, all cell barcodes are plotted on the x-axis and \code{nbcs} is used
#' to specified the default view. Turning this option on might result in very large objects!
#'
#' @param title String containing plot title.
#' 
#' @param ncells Number of estimated cells (default: NULL). If specified, a  vertical line will be
#' drawn at this number of cell barcodes.
plot_cumfrac_rpc <- function(cumfrac, nbcs, all = FALSE, title = NULL, ncells = NULL) {
  
  # only retain data on nbcs cells if all is disabled
  if (all == FALSE) cumfrac <- cumfrac[1:nbcs, ]
  
  # add index used for plotting
  cumfrac$index <- 1:nrow(cumfrac)
  
  # function to create vertical line in plotly
  vline <- function(x = 0, color = "red") {
    
    # convert x to NUll if it is NA
    if (is.na(x)) x <- NULL
    
    # create list with line parameters
    list(
      type = "line", 
      y0 = 0, 
      y1 = 1, 
      yref = "paper",
      x0 = x, 
      x1 = x, 
      line = list(color = color)
    )
    
  }
  
  # create line at estimated number of cells (if available)
  if (is.na(ncells) | is.null(ncells)) {
    
    ncells_line <- NULL
    
  }else{
    
    ncells_line <- list(vline(ncells))
    
  }
  
  # define axes
  xaxis <- list(title = "Cell barcodes sorted by number of reads [descending]", range = c(0, nbcs))
  yaxis <- list(title = "Cumulative fraction of reads", range = c(0, 1))
  
  # create interactive line plot using plotly
  p <- plot_ly(cumfrac, x = ~index, y = ~reads_cumfrac, type = "scatter", mode = "lines",
               hoverinfo = "text", 
               text = ~paste0("Cells: ", index, "\n",
                              "Reads cell i: ", reads, "\n",
                              "Total reads: ", reads_cumsum, "\n",
                              "Cumfrac reads: ", round(reads_cumfrac, digits = 2))
  )
  
  # format title and axes and add vertival ncells line
  layout(p, title = title, xaxis = xaxis, yaxis = yaxis, shapes = ncells_line)
  
}

#' Plot reads per cell barcode
#' 
#' Plot reads per cell barcode distribution for all cell barcodes ordered by the number of reads
#' 
#' @param cumfrac A data.frame containing the cumulative fraction of reads per cell barcode
#' calculated by cumfrac_rpc().
#' 
#' @param title String containing plot title.
#' 
#' @param ncells Number of estimated cells (default: NULL). If specified, a vertical line will be
#' drawn at this number of cell barcodes.
plot_rpc_distr <- function(cumfrac, title = NULL, ncells = NULL) {
  
  # add index used for plotting
  cumfrac$index <- 1:nrow(cumfrac)
  
  # function to create vertical line in plotly
  vline <- function(x = 0, color = "red") {
    
    # create list with line parameters
    list(
      type = "line", 
      y0 = 0, 
      y1 = 1, 
      yref = "paper",
      x0 = x, 
      x1 = x, 
      line = list(color = color)
    )
    
  }
  
  # create line at estimated number of cells (if available)
  if (is.na(ncells) | is.null(ncells)) {
    
    ncells_line <- NULL
    
  }else{
    
    ncells_line <- list(vline(ncells))
    
  }
  
  # define axes
  xaxis <- list(title = "Cell barcodes sorted by number of reads [descending]", type = "log")
  yaxis <- list(title = "Number of reads", type = "log")
  
  # create interactive line plot using plotly
  p <- plot_ly(cumfrac, x = ~index, y = ~reads, type = "scatter", mode = "lines",
               hoverinfo = "text",
               text = ~paste0("Cells: ", index, "\n",
                              "Reads cell i: ", reads, "\n",
                              "Total reads: ", reads_cumsum, "\n",
                              "Cumfrac reads: ", round(reads_cumfrac, digits = 2))
  )
  
  layout(p, shapes = ncells_line, xaxis = xaxis, yaxis = yaxis, title = title)
  
}

#' Local minima in multimodal distribution
#' 
#' Find the local minima between peaks of a multimodal distribution. Works best if applied to the
#' output of a density kernel.
#' 
#' @param x Numeric vector containing the data series in which local minima should be found.
#' 
#' @return Vector containing indices of local minima in x.
local_minima <- function(x) {
  
  # get segments where value increases (TRUE) or decreases (FALSE) -Inf at the beginning ensures
  # that the first segment (even if it's only one element) is an increase
  increase <- diff(c(-Inf, x)) > 0L
  
  # get turn points, where x changes between increasing and decreasing
  turns <- cumsum(rle(increase)$lengths)
  
  # get minima based on the fact that the first segment is an inrease and the
  # first turn point therefore a local maximum
  if (length(turns) > 2) {
    
    turns[seq.int(from = 2, to = length(turns) - 1, by = 2)]
    
  }else{
    
    as.integer(NA)
    
  }
  
}

#' Compute reads per cell barcode distribution
#' 
#' Apply a density kernel to compute reads per cell barcode distribution. This is expected to result
#' in a bimodal distribution, with real cells and ambient RNA separated by a local mimimum between
#' the two distributions. The function calculates local minima in the distribution and tries to
#' estimate the number of cells in the sample.
#' 
#' @param read_counts_file Path to output file from BAMTagHistogram containing the number of reads
#' per cell barcode. This file should contain two columns, where the number of reads must be in the
#' first and the barcode identity in the second column.
#' 
#' @param expect_cells Integer; A rough estimate of the number of cells contained in the sample.
#' 
#' @return A list containing the computed density (data.frame), reads at local minima, number of
#' used cell barcodes and estimated number of cells.
rpc_density <- function(read_counts_file, expect_cells) {
  
  # calculate number of cell barcodes to be included in analysis
  nbcs <- expect_cells * 2
  
  # load read per cell file
  read_counts <- read.table(read_counts_file, stringsAsFactors = FALSE)
  colnames(read_counts)[1:2] <- c("reads", "cell_barcode")
  
  # calculate log10 number of reads to calculate density
  read_counts$log10_reads <- log10(read_counts$reads)
  
  # calculate density
  dens <- density(read_counts[1:nbcs, "log10_reads"])
  
  # create data.frame with x and y values
  dens <- data.frame(density = dens$y, log10_reads = dens$x)
  
  # calculate approximate number of cells that would be included if the minimum
  # reads cutoff would be made at that position
  dens_cumfrac <- cumsum(dens$density) / sum(dens$density)
  approx_cells <- (1 - dens_cumfrac) * nbcs
  dens$approx_cells <- ceiling(approx_cells / 50) * 50
  
  # find first local minimum in the log10 read density distribution
  loc_min <- local_minima(dens$density)[1]
  loc_min_log_reads <- dens$log10_reads[loc_min]
  loc_min_reads <- 10 ^ loc_min_log_reads
  
  # get estimated number of cells
  ncells <- sum(read_counts$reads >= loc_min_reads)
  
  # create output object containing all data
  list(density = dens, loc_min_log_reads = loc_min_log_reads, loc_min_reads = loc_min_reads,
       cell_bcs = nbcs, ncells = ncells)
  
}

#' Plot reads per cell barcode distribution
#' 
#' Plot the computed reads per cell barcode density distribution
#' 
#' @param dens_obj Output from rpc_density() function containing computed density and local minima.
plot_rpc_density <- function(dens_obj, title = NULL) {
  
  # unpack dens_obj
  dens <- dens_obj$dens
  loc_min_log_reads <- dens_obj$loc_min_log_reads
  nbcs <- dens_obj$cell_bcs
  
  # function to add vertical line in plotly
  vline <- function(x = 0, color = "red") {
    
    list(
      type = "line", 
      y0 = 0, 
      y1 = 1, 
      yref = "paper",
      x0 = x, 
      x1 = x, 
      line = list(color = color)
    )
    
  }
  
  # create list of vertical lines, one per local minimum
  if (!is.na(loc_min_log_reads)) {
    
    loc_min_lines <- lapply(loc_min_log_reads, FUN = vline)
    
  }else{
    
    loc_min_lines <- NULL
    
  }
  
  # create plot
  p <- plot_ly(dens, x = ~log10_reads, y = ~density, type = "scatter", mode = "lines",
               hoverinfo = "text",
               text = ~paste0("Log10 reads: ", log10_reads, "\n",
                              "Reads: ", round(10 ^ log10_reads), "\n",
                              "Approx cells: ", approx_cells))
  
  # add lines and title  
  layout(p, shapes = loc_min_lines, title = title)
  
}
