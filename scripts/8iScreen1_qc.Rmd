---
title: "8iScreen1 QC"
author: "Andreas Gschwind"
date: "`r format(Sys.time(), '%B %d, %Y')`"
params:
  rmd: "8iScreen1_qc.Rmd"
output:
  bookdown::html_document2:
    toc: yes
---

# Goal
General QC of 8iScreen1 perturbations and DGE data.
```{css echo=FALSE}
/* Define a margin before every image element */
img {
  margin-top: 3em;
}
```

```{r setup, include=FALSE}
# set global chunk options
knitr::opts_chunk$set(echo = FALSE)

# attach required packages
library(tidyverse)
library(gridExtra)
library(ggrepel)
library(GGally)
library(here)
```

```{r prepData}
# load target genes
target_genes <- read.csv(here(snakemake@input$target_genes), stringsAsFactors = FALSE)

# load dge summary
dge_stats <- read.table(here(snakemake@input$dge_stats), header = TRUE, stringsAsFactors = FALSE)

# load dge data
dge <- read.table(here(snakemake@input$dge), header = TRUE, stringsAsFactors = FALSE,
                  row.names = "GENE")

# dge input files from chr8 validation experiments
valid_dge_files <- grep(snakemake@input$valid_dge, pattern = "8iv2", value = TRUE)
valid_dge_files <- here(valid_dge_files)
names(valid_dge_files) <- basename(dirname(valid_dge_files))

# load validation dge data
valid_dge <- lapply(valid_dge_files, FUN = read.table, header = TRUE, stringsAsFactors = FALSE)

# load perturbation status
perturb_status <- read.table(here(snakemake@input$pert), header = TRUE, stringsAsFactors = FALSE,
                             row.names = "VECTOR")

# load experimental meta data and extract data on 8i samples
exp_data <- read.csv(here(snakemake@input$exp_data), stringsAsFactors = FALSE) %>%
  filter(panel == "chr8i")

# get transfected vector ids
vectors_file <- here(snakemake@input$vctr_seqs)
vectors <- vectors_file %>%
  readLines() %>%
  grep(pattern = "^>.+$", perl = TRUE, value = TRUE) %>%
  sub(., pattern = ">", replacement = "") %>%
  data.frame(vector = ., stringsAsFactors = FALSE)

# extract vector expression from dge data
vector_pattern <- snakemake@params$vector_pattern
vector_rows <- grep(rownames(dge), pattern = vector_pattern)
vctr_expr <- dge[vector_rows, ]

# extract gene expression data
gene_expr <- dge[-vector_rows, ]
```

# Batch effects
Multiple 10x lanes were used in parallel to process the high number of cells. Here the DGE data is
assessed for any batch effects resulting from using different lanes. Cell barcodes start with i7
barcodes, which correspond to individual 10x lanes. Metadata on used 10x lanes is used to assign
each cell to its 10x lane.

# Number of cells and genes
The number of cells and detected genes per cell are plotted for each 10x lane.

```{r cellsGenes, fig.height=7, fig.width=5}
# split cell barcode into i7 and cell
dge_stats <- separate(dge_stats, col = cell_barcode, into = c("i7_index", "cell"), sep = 8)

# add variable for 10x lane
dge_stats <- left_join(dge_stats, select(exp_data, name, i7_index), by = "i7_index")

# plot number of cells per lane
p1 <- ggplot(dge_stats, aes(x = name, fill = name)) +
  geom_bar() +
  theme_bw() +
  labs(x = "10x lane", y = "Cells", title = "Number of cells per 10x lane") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

# plot number of detected genes per cell
p2 <- ggplot(dge_stats, aes(x = name, y = genes, color = name)) +
  geom_jitter(width = 0.1, alpha = 0.2) +
  geom_boxplot(color = "black", fill = NA, outlier.shape = NA, notch = TRUE) +
  labs(x = "10x lane", y = "Detected genes", title = "Detected genes per cell") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

# print plots
grid.arrange(p1, p2, nrow = 2, ncol = 1)
```

## Number of genic reads and transcripts
The number of detected transcripts per cell vs genic reads is plotted and compared between different
10x lanes.

```{r TxsVsReads, fig.height=7, fig.width=7}
# plot number of transcripts vs genic reads
p1 <- ggplot(dge_stats, aes(x = transcripts, y = genic_reads, color = name)) +
  geom_point() +
  labs(x = "Transcripts", y = "Genic reads", title = "Transcripts vs. genic reads",
       color = "10x lane") +
  scale_x_log10() +
  scale_y_log10() +
  theme_bw() +
  theme(legend.position = "none")

# plot number of genic reads per cell
p2 <- ggplot(dge_stats, aes(x = name, y = genic_reads, color = name)) +
  geom_jitter(width = 0.1, alpha = 0.2) +
  geom_boxplot(color = "black", fill = NA, outlier.shape = NA, notch = TRUE) +
  labs(x = "10x lane", y = "Genic reads", title = "Genic reads per cell") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

# plot number of transcripts per cell
p3 <- ggplot(dge_stats, aes(x = name, y = transcripts, color = name)) +
  geom_jitter(width = 0.1, alpha = 0.2) +
  geom_boxplot(color = "black", fill = NA, outlier.shape = NA, notch = TRUE) +
  labs(x = "10x lane", y = "Transcripts", title = "Transcripts per cell") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

# print plots
layout <- rbind(c(1, 1),
                c(2, 3))
grid.arrange(p1, p2, p3, layout_matrix = layout)
```

## Average gene expression
The average expression per gene is calculated across all cells of a given lane. The average
expression is then plotted to compare different 10x lanes.

```{r avgGenex, fig.width=5, fig.height=4}
# transpose gene expression, split cell barcode into i7 + cell, convert to long format
gene_expr_l <- t(gene_expr) %>%
  as.data.frame() %>%
  rownames_to_column(var = "cell_barcode") %>%
  separate(cell_barcode, into = c("i7_index", "cell"), sep = 8) %>%
  gather(key = "gene", value = "txs", -c(i7_index, cell))

# add variable for 10x lane
gene_expr_l <- left_join(gene_expr_l, select(exp_data, name, i7_index), by = "i7_index")
  
# compute average gene expression per 10x lane
avg_genex_lanes <- gene_expr_l %>%
  group_by(name, gene) %>%
  summarize(avg_txs = mean(txs))

# plot average gene expression
ggplot(avg_genex_lanes, aes(x = name, y = avg_txs, color = name)) +
  geom_jitter(width = 0.25, alpha = 0.5) +
  geom_boxplot(color = "black", fill = NA, notch = TRUE, outlier.shape = NA) +
  labs(x = "10x lane", y = "Average transcripts per gene", title = "Transcripts per gene") +
  scale_y_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
```

```{r pairwisePlots, fig.height=10, fig.width=10}
# calculate log10 average gene expression and reformat
avg_genex_log10 <- avg_genex_lanes %>%
  mutate(avg_txs = log10(avg_txs)) %>%
  spread(key = "name", value = "avg_txs")

# plot pairwise correlations between 10x lanes
ggpairs(avg_genex_log10, columns = 2:ncol(avg_genex_log10), progress = FALSE)
```

## Principal component analysis
Principal component analysis (PCA) is performed on gene expression data to check whether any
outliers can be identified, wich could be explained by batch effects caused by different 10x lanes.
Because the transfected CROP-seq vectors are highly variable and not present in every cell, this
analysis is only performed with expression data on genes.

```{r PCAgenex, fig.height = 7}
# convert gene expression into data matrix and transpose for pca
genex_mat <- t(data.matrix(gene_expr))

# compute PCA on DGE data
pca_genex <- prcomp(genex_mat, scale. = TRUE)

# extract scores of each cell for pc1 & pc2
pcs <- pca_genex$x[, 1:2] %>%
  as.data.frame() %>%
  rownames_to_column(var = "cell_barcode")

# split cell barcode into i7 and cell and meta data to each cell
pcs <- pcs %>%
  separate(cell_barcode, into = c("i7_index", "cell"), sep = 8) %>%
  left_join(select(exp_data, i7_index, chip_10x, lane_10x, bead_vial_10x, name),
            by = "i7_index") %>%
  rename(lane_number_10x = lane_10x, sample_id_10x = name) %>%
  gather(key = "confounder", value = "value", -c(i7_index, cell, PC1, PC2))

# get variance explained for pcs
pca_sum <- summary(pca_genex)
var_expl <- pca_sum$importance["Proportion of Variance", ]

# create axis labels
x_axis <- paste0("PC1 (", (round(var_expl["PC1"], digits = 4) * 100), "% variance explained)")
y_axis <- paste0("PC2 (", (round(var_expl["PC2"], digits = 4) * 100), "% variance explained)")

# plot 1st and 2nd PC for each potential confounder
plots <- by(pcs, INDICES = pcs$confounder, function(x) {
  title <- paste("Potential confounder:", unique(x$confounder))
  ggplot(x, aes(x = PC1, y = PC2, color = as.factor(value))) +
    geom_point(size = 1) +
    labs(x = x_axis, y = y_axis, color = "Confounder", title = title) +
    coord_fixed() +
    guides(colour = guide_legend(override.aes = list(alpha = 1))) +
    theme_bw()
})

# print plots
do.call(grid.arrange, c(plots, nrow = 2, ncol = 2))
```

***

# CROP-seq vectors
The number of detected transcripts and perturbations per transfected vector are assessed.

```{r vctrExpr, fig.height=10, fig.width=9}
# number of molecules per vector (all transfected vectors)
txs_per_vector <- rowSums(vctr_expr) %>%
  data.frame(vector = names(.), txs = ., stringsAsFactors = FALSE) %>%
  mutate(vector = sub(vector_pattern, "", vector)) %>%
  full_join(vectors, by = "vector") %>%
  mutate(txs = replace(txs, is.na(txs), 0))

# compute the number of cells per perturbation
cells_per_pert <- rowSums(perturb_status) %>%
  data.frame(vector = names(.), cells = ., stringsAsFactors = FALSE)

# merge with txs_per_vector and calculate average vector txs per transfected cell (if possible)
vector_stats <- txs_per_vector %>%
  full_join(cells_per_pert, by = "vector") %>%
  mutate(cells = replace(cells, is.na(cells), 0)) %>%
  mutate(avg_txs = if_else(cells > 0, true = txs / cells, false = as.numeric(NA)))

# add label for control vectors
ctrl_vctrs <- grep(vector_stats$vector, pattern = "^chr8:.+$", perl = TRUE,
                   invert = TRUE, value = TRUE)

vector_stats <- vector_stats %>%
  mutate(type = if_else(vector %in% ctrl_vctrs, true = "ctrl", false = "screen"))

# plot total number of detected transcripts per vector
p11 <- ggplot(vector_stats, aes(x = fct_reorder(vector, txs, .desc = TRUE), y = txs, color = type)) +
  geom_point() +
  labs(x = "vectors", y = "transcripts", title = "Detected vector transcripts 8iScreen1") +
  scale_color_manual(values = c("ctrl" = "firebrick1", "screen" = "steelblue3")) +
  theme_bw() +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), panel.grid = element_blank())

p12 <- ggplot(vector_stats, aes(txs)) +
  geom_histogram(bins = 50) +
  labs(title = "Detected vector transcripts 8iScreen1") +
  theme_bw()

# plot number of cells per perturbation
n_50_plus <- sum(vector_stats$cells >= 50)
title <- paste0("Cells per perturbation 8iScreen (", n_50_plus, " >= 50)")

p21 <- ggplot(vector_stats,
              aes(x = fct_reorder(vector, cells, .desc = TRUE),y = cells, color = type)) +
  geom_point() +
  geom_hline(yintercept = 50, lty = "dashed", col = "darkgray") +
  scale_color_manual(values = c("ctrl" = "firebrick1", "screen" = "steelblue3")) +
  labs(x = "vectors", y = "cells", title = title) +
  theme_bw() +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), panel.grid = element_blank())

p22 <- ggplot(vector_stats, aes(cells)) +
  geom_histogram(bins = 50) +
  labs(title = "Cells per perturbation 8iScreen") +
  theme_bw()

# plot average expression per cell for successful vectors
p31 <- vector_stats %>%
  filter(cells > 0) %>%
  ggplot(., aes(x = fct_reorder(vector, avg_txs, .desc = TRUE), y = avg_txs, color = type)) +
  geom_point() +
  labs(x = "vectors", y = "txs per cell", title = "Txs per transfected cell 8iScreen1") +
  scale_color_manual(values = c("ctrl" = "firebrick1", "screen" = "steelblue3")) +
  theme_bw() +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), panel.grid = element_blank())

p32 <- vector_stats %>%
  filter(cells > 0) %>%
  ggplot(., aes(avg_txs)) +
  geom_histogram(bins = 50) +
  labs(title = "Txs per transfected cell 8iScreen1") +
  theme_bw()

# print plots
grid.arrange(p11, p12, p21, p22, p31, p32, ncol = 2, nrow = 3)
```

***

# Gene expression

## Correlation with validation experiments
The average expression per gene (across all 10x lanes) is computed and correlated with data from the
chr8 validation experiments.

```{r genexCorrelation}
# compute average gene expression per gene
avg_genex <- gene_expr_l %>%
  group_by(gene) %>%
  summarize(avg_txs = mean(txs))

# known enhancer genes
known_enh <- target_genes %>%
  filter(screen == "validation") %>%
  filter(!gene %in% c("HBG1", "HBG2")) %>%  # HBG genes were removed from screen
  pull(gene)

# chr8 target genes
chr8_genes <- target_genes %>%
  filter(panel %in% c( "chr8_myc", "chr8_zfpm2"), screen == "inhibition") %>%
  pull(gene) %>%
  c(known_enh)

# average gene expression in validation experiments
avg_genex_valid <- valid_dge %>%
  lapply(FUN = gather, key = "cell", value = "txs", -GENE) %>%
  bind_rows(.id = "sample") %>%
  filter(GENE %in% chr8_genes) %>%
  group_by(GENE) %>%
  summarize(avg_txs_valid = mean(txs))

# merge avg genex datasets and add variable for known enhancer target genes
avg_genex_merged <- full_join(avg_genex, avg_genex_valid, by = c("gene" = "GENE")) %>%
  mutate(type = if_else(gene %in% known_enh, true = "e-gene", "non_e-gene"))

# correlation plot
ggplot(avg_genex_merged, aes(x = avg_txs_valid, y = avg_txs, color = type)) +
  geom_abline() +
  geom_point() +
  geom_text_repel(data = filter(avg_genex_merged, type == "e-gene" | gene == "STK3"),
                  aes(label = gene), box.padding = unit(1.5, "lines"), color = "gray50") +
  labs(title = "Average gene expression", x = "8iv210ng & 8iv22ng", y = "8iScreen1") +
  scale_color_manual(values = c("e-gene" = "firebrick1", "non_e-gene" = "steelblue3")) +
  scale_x_log10() +
  scale_y_log10() +
  coord_fixed() +
  theme_bw()
```

## Control perturbation effects
Data on the validation enhancers is extracted and the LFC between cells carrying positive control
perturbations and non-targeting controls is calculated.

```{r grnasToTargets}
# get grna identifiers
grnas <- rownames(perturb_status)

# get indexes of screen grnas
screen_grnas <- grep(grnas, pattern = "^chr.+:\\d+-\\d+.*$", perl = TRUE)

# get non-targeting negative control grnas
neg_ctrls <- grep(grnas, pattern = "^non-targeting_.+$", perl = TRUE)

# convert grna ids to grna targets
grnas[screen_grnas] <- sub("_\\d+.+$", "", grnas[screen_grnas])
grnas[neg_ctrls] <- sub("_\\d+$", "", grnas[neg_ctrls])
grnas[-c(screen_grnas, neg_ctrls)] <- sub("[_|-].*" , "", grnas[-c(screen_grnas, neg_ctrls)])

# add targets as separate column to perturb_status
perturb_status <- data.frame(target = grnas, perturb_status, stringsAsFactors = FALSE)
```

```{r controlPerturbations}
# get rows containing negative or positive controls, or screen perturbations
targets <- perturb_status$target
neg_ctrl_rows    <- which(targets == "non-targeting")
screen_pert_rows <- grep(targets, pattern = "^chr8:.+$", perl = TRUE)
pos_ctrl_rows    <- which(!targets %in% c("non-targeting", perturb_status$target[screen_pert_rows]))

# get cells carrying non-targeting controls or any other enhancer perturbations
neg_ctrl <- colSums(perturb_status[neg_ctrl_rows, -1]) > 0
enh_pert <- colSums(perturb_status[c(screen_pert_rows, pos_ctrl_rows), -1]) > 0

# get cell barcodes of cells only carrying non-targeting controls
neg_ctrl_cells <- data.frame(neg_ctrl, enh_pert) %>%
  rownames_to_column(var = "cell") %>%
  filter(neg_ctrl == TRUE, enh_pert == FALSE) %>%
  pull(cell)

# get cells carrying any positive control perturbation
pos_ctrl <- colSums(perturb_status[pos_ctrl_rows, -1]) > 0
pos_ctrl_cells <- names(pos_ctrl[pos_ctrl])

# filter for control perturbations and cells carrying them
pert_ctrls <- perturb_status[c(pos_ctrl_rows, neg_ctrl_rows),
                             c("target", pos_ctrl_cells, neg_ctrl_cells)]

# transform to long format and count number of perturbations per cell and target
pert_ctrls <- gather(pert_ctrls, key = "cell_barcode", value = "pert", -target) %>%
  filter(pert > 0) %>%
  count(cell_barcode, target) %>%
  rename(pert = n)
```

```{r controlEffects, fig.height=18, fig.width=7}
# get gene expression data for cells carrying control perturbations
genex_pert <- gene_expr_l %>%
  unite(col = "cell_barcode", i7_index, cell, sep = "") %>%
  filter(cell_barcode %in% unique(pert_ctrls$cell_barcode))

# merge with perturbation information
genex_pert <- left_join(genex_pert, pert_ctrls, by = "cell_barcode")

# calculate average gene expression of each gene in every perturbation
avg_genex_pert <- genex_pert %>%
  group_by(target, gene) %>%
  summarize(avg_txs = mean(txs))

# reformat so that rows contain a positive control perturbation and negative control expression
avg_genex_pert <- avg_genex_pert %>%
  spread(key = target, value = avg_txs) %>%
  gather(key = target, value = avg_txs, -c("gene", "non-targeting")) %>%
  rename(neg_ctrl = "non-targeting") %>%
  select(gene, target, avg_txs, neg_ctrl)

# calculate log fold change for each gene in each perturbation
lfc_pert <- avg_genex_pert %>%
  filter(avg_txs > 0) %>%  # filter genes with detected expression for the given perturbations
  mutate(fc = avg_txs / neg_ctrl,
         lfc = log2(fc))

# list of perturbations and their target genes
perturbations <- as.list(unique(lfc_pert$target))
names(perturbations) <- unlist(perturbations)
perturbations$HS2 <- c("HBB", "HBD", "HBE1", "HBG1", "HBG2")

# add variable indicating if a gene is a target of the given perturbation
lfc_pert <- lfc_pert %>%
  group_by(target) %>%
  mutate(type = if_else(gene %in% unlist(perturbations[target]),
                        true = "target", false = "non_target"))

# plot lfc for all perturbations
ggplot(lfc_pert, aes(x = lfc, y = gene, color = type)) +
  facet_wrap(~target, ncol = 3) +
  geom_vline(xintercept = c(-1, 1), lty = "dashed", color = "darkgray") +
  geom_vline(xintercept = 0, color = "darkgray") +
  geom_point() +
  geom_text_repel(data = filter(lfc_pert, abs(lfc) > 0.75), aes(label = gene),
                  box.padding = unit(1.5, "lines"), color = "gray50") +
  labs(title = "LFC perturbations vs. negative controls") +
  scale_color_manual(values = c("target" = "firebrick1", "non_target" = "steelblue3")) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 5))
```

Non-target genes with LFC > 0.75 are considered potential false positives. Their expression levels
and proportion of cells with zero expression are calculated. Low expression and large number of
cells with no expression could make the observed LFC more prone to noise, leading to false
positives.

```{r, fig.width=11, fig.height=4}
# get average gene expression of non_targets that show a |lfc| > 0.75
potential_fp <- filter(lfc_pert, type == "non_target", abs(lfc) > 0.75) %>%
  pull(gene) %>%
  unique()

# get average expression of all genes and mark potential false positives
avg_genex_fp <- avg_genex %>%
  mutate(type = if_else(gene %in% potential_fp, true = "false_pos?", false = "other"))

# plot average expression of these genes vs other gene
p1 <- ggplot(avg_genex_fp, aes(x = type, y = avg_txs, fill = type, color = type)) +
  geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.15) +
  geom_text_repel(data = filter(avg_genex_fp, type == "false_pos?"), aes(label = gene),
                  color = "gray50") +
  labs(title = "Average expression potential false positives") +
  scale_color_manual(values = c("false_pos?" = "firebrick1", "other" = "steelblue3")) +
  scale_fill_manual(values = c("false_pos?" = "firebrick1", "other" = "steelblue3")) +
  scale_y_log10() +
  theme_bw()

# compute percentage of 0s for each gene
zeros <- gene_expr_l %>%
  group_by(gene) %>%
  summarize(zeros = sum(txs == 0), 
            prop_zeros = zeros / n()) %>%
  mutate(type = if_else(gene %in% potential_fp, true = "false_pos?", false = "other"))

# plot proportion of cells with zero expression
p2 <- ggplot(zeros, aes(x = type, y = prop_zeros, fill = type, color = type)) +
  geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.025) +
  geom_text_repel(data = filter(zeros, type == "false_pos?"), aes(label = gene), color = "gray50") +
  labs(title = "Proportion of cells with 0s") +
  scale_color_manual(values = c("false_pos?" = "firebrick1", "other" = "steelblue3")) +
  scale_fill_manual(values = c("false_pos?" = "firebrick1", "other" = "steelblue3")) +
  theme_bw()

# print plots
grid.arrange(p1, p2, ncol = 2)
```

***

# Source
* <a download="8iScreen1_qc.Rmd" href="`r base64enc::dataURI(file = params$rmd,
    mime = 'text/rmd', encoding = 'base64')`">R Markdown source file (to produce this document)</a>
